package analizadorlexico;
import java_cup.runtime.*;
import analizadorlexico.AST.*;
import analizadorlexico.AST.Declaration.*;
import analizadorlexico.AST.Statement.*;
import analizadorlexico.AST.Primary.*;
import analizadorlexico.AST.Expression.*;

parser code {:
    public void syntax_error(Symbol cur_token){
        System.out.print("Syntax Error:");
        System.out.print(" line:" + cur_token.left);
        System.out.print(" column:" + cur_token.right);
        System.out.println();
    }

    public void expected_token(String token){
      System.out.print("Expected Token " + token);
      System.out.println();
    };

:}

/*TERMINAL (FLEX)*/
terminal PROCEDURE, IS, BEGIN, END, PUT, NEW_LINE, WITH, OPEN_PARENTHESIS;
terminal CLOSE_PARENTHESIS, SUM_OPERATOR, MULT_OPERATOR, RELATION_OPERATOR;
terminal TYPE, LITERAL_BOOLEAN, LITERAL_INT, END_INSTRUCTION, LITERAL_CHAR;
terminal IF,ELSE,ELSEIF,THEN,FOR,IN,OUT,LOOP,WHILE,ID,ASIGNATION;
terminal DECLARATION, EXIT, WHEN, COMMA, LITERAL_STRING,CONDITION_ELEMENT;
terminal CONSTANT,FUNCTION,PACKAGE,BODY,RETURN,NULL,CASE,CASEASIG;
terminal REVERSE,OTHERS,TO;

/*NON TERMINAL*/
non terminal InitProcedure procedure;
non terminal Statement asignation,statement,if,if_a,case,while,for;
non terminal CaseBody case_a;
non terminal Statement function_call_statement;
non terminal Primary function_call,primary;
non terminal ListPrimary list_primary, parameters;
non terminal Declaration declaration,in_out_declaration,simple_declaration;
non terminal Expression expression,simple_expression,mathematical_expression,mult_operation,parenthesis_operation;
non terminal Expression condition_expression,relation_expression;
non terminal Condition condition;


non terminal constant;
non terminal list_declaration_parameters;
non terminal input_parameters;


/*PRECEDENCE*/
precedence left CONDITION_ELEMENT;
precedence left RELATION_OPERATOR;
precedence left SUM_OPERATOR;
precedence left MULT_OPERATOR;


/* GRAMMARS */
procedure ::= PROCEDURE ID IS declaration:d BEGIN statement:s END ID END_INSTRUCTION
              {: RESULT = new InitProcedure(d,s); :};
declaration ::= simple_declaration END_INSTRUCTION declaration
          | PROCEDURE ID input_parameters IS declaration BEGIN statement END ID END_INSTRUCTION declaration
          | FUNCTION ID input_parameters RETURN TYPE IS declaration BEGIN statement END ID END_INSTRUCTION declaration
          | ;
input_parameters ::= OPEN_PARENTHESIS list_declaration_parameters CLOSE_PARENTHESIS
                      |;
list_declaration_parameters ::= simple_declaration END_INSTRUCTION list_declaration_parameters
                      | in_out_declaration END_INSTRUCTION list_declaration_parameters
                      | simple_declaration
                      | in_out_declaration;
in_out_declaration ::= ID DECLARATION IN TYPE
                  | ID DECLARATION OUT TYPE
                  | ID DECLARATION IN OUT TYPE;
simple_declaration ::= ID DECLARATION constant TYPE
                    | ID COMMA simple_declaration
                    | ID DECLARATION constant TYPE ASIGNATION expression END_INSTRUCTION;
constant ::= CONSTANT
          |;
statement ::= asignation END_INSTRUCTION statement
          |   NEW_LINE END_INSTRUCTION statement
          |   if END_INSTRUCTION statement
          |   case END_INSTRUCTION statement
          |   while END_INSTRUCTION statement
          |   for END_INSTRUCTION statement
          |   RETURN expression END_INSTRUCTION statement
          |   function_call_statement statement
          |;
function_call_statement ::= function_call END_INSTRUCTION;
condition ::= expression;
simple_expression ::= ;
mathematical_expression ::= mathematical_expression SUM_OPERATOR mult_operation
          | mult_operation;
mult_operation ::= mult_operation MULT_OPERATOR parenthesis_operation
          | parenthesis_operation;
parenthesis_operation ::= OPEN_PARENTHESIS mathematical_expression CLOSE_PARENTHESIS
          | LITERAL_INT
          | ID
          | function_call;
expression ::= relation_expression
          | condition_expression
          | mathematical_expression;

relation_expression ::= expression RELATION_OPERATOR expression;
condition_expression ::= expression CONDITION_ELEMENT expression
                    |   OPEN_PARENTHESIS condition_expression CLOSE_PARENTHESIS;

primary  ::= LITERAL_BOOLEAN
          |   LITERAL_INT
          |   LITERAL_STRING
          |   ID
          |   function_call;
asignation   ::= ID ASIGNATION expression
            | ID ASIGNATION LITERAL_BOOLEAN
            | ID ASIGNATION LITERAL_STRING
            | error expression {: parser.expected_token(":="); :}
            | error LITERAL_BOOLEAN {: parser.expected_token(":="); :}
            | error LITERAL_STRING {: parser.expected_token(":="); :}
            | error {: parser.expected_token(":="); :};
list_primary ::= primary COMMA list_primary
            | primary;
parameters ::= list_primary
          |;

if  ::= IF condition:c THEN statement:s if_a:ef END IF
        {: RESULT = new IfStatement(c,s,ef); :};
if_a ::= ELSEIF condition:c THEN statement:s if_a:ef
        {: RESULT = new IfStatement(c,s,ef); :}
        | ELSE statement:s
        {: RESULT = new IfStatement(s); :}
        |
        {: RESULT = new IfStatement(); :} ;

case  ::= CASE primary:p IS case_a:cb END CASE
          {: RESULT = new CaseStatement(p,cb); :};
case_a ::= WHEN primary:p CASEASIG statement:s case_a:cb
          {: RESULT = new CaseBody(p,s,cb); :}
          |
          {:RESULT = new CaseBody(); :} ;

while ::= WHILE condition:c LOOP statement:s END LOOP
        {: RESULT = new WhileStatement(c,s); :};

for   ::= FOR asignation:a TO expression:e statement:s END FOR
        {: RESULT = new ForStatement(a,s,e); :};

function_call ::= ID OPEN_PARENTHESIS parameters CLOSE_PARENTHESIS
              |   PUT OPEN_PARENTHESIS parameters CLOSE_PARENTHESIS;
